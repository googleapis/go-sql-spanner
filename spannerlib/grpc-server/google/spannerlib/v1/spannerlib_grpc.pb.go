// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.1
// source: google/spannerlib/v1/spannerlib.proto

package spannerlibpb

import (
	spannerpb "cloud.google.com/go/spanner/apiv1/spannerpb"
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SpannerLib_Info_FullMethodName             = "/google.spannerlib.v1.SpannerLib/Info"
	SpannerLib_CreatePool_FullMethodName       = "/google.spannerlib.v1.SpannerLib/CreatePool"
	SpannerLib_ClosePool_FullMethodName        = "/google.spannerlib.v1.SpannerLib/ClosePool"
	SpannerLib_CreateConnection_FullMethodName = "/google.spannerlib.v1.SpannerLib/CreateConnection"
	SpannerLib_CloseConnection_FullMethodName  = "/google.spannerlib.v1.SpannerLib/CloseConnection"
	SpannerLib_Execute_FullMethodName          = "/google.spannerlib.v1.SpannerLib/Execute"
	SpannerLib_ExecuteStreaming_FullMethodName = "/google.spannerlib.v1.SpannerLib/ExecuteStreaming"
	SpannerLib_ExecuteBatch_FullMethodName     = "/google.spannerlib.v1.SpannerLib/ExecuteBatch"
	SpannerLib_Metadata_FullMethodName         = "/google.spannerlib.v1.SpannerLib/Metadata"
	SpannerLib_Next_FullMethodName             = "/google.spannerlib.v1.SpannerLib/Next"
	SpannerLib_ResultSetStats_FullMethodName   = "/google.spannerlib.v1.SpannerLib/ResultSetStats"
	SpannerLib_NextResultSet_FullMethodName    = "/google.spannerlib.v1.SpannerLib/NextResultSet"
	SpannerLib_CloseRows_FullMethodName        = "/google.spannerlib.v1.SpannerLib/CloseRows"
	SpannerLib_BeginTransaction_FullMethodName = "/google.spannerlib.v1.SpannerLib/BeginTransaction"
	SpannerLib_Commit_FullMethodName           = "/google.spannerlib.v1.SpannerLib/Commit"
	SpannerLib_Rollback_FullMethodName         = "/google.spannerlib.v1.SpannerLib/Rollback"
	SpannerLib_WriteMutations_FullMethodName   = "/google.spannerlib.v1.SpannerLib/WriteMutations"
	SpannerLib_ConnectionStream_FullMethodName = "/google.spannerlib.v1.SpannerLib/ConnectionStream"
)

// SpannerLibClient is the client API for SpannerLib service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SpannerLibClient interface {
	Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error)
	CreatePool(ctx context.Context, in *CreatePoolRequest, opts ...grpc.CallOption) (*Pool, error)
	ClosePool(ctx context.Context, in *Pool, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreateConnection(ctx context.Context, in *CreateConnectionRequest, opts ...grpc.CallOption) (*Connection, error)
	CloseConnection(ctx context.Context, in *Connection, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*Rows, error)
	ExecuteStreaming(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RowData], error)
	ExecuteBatch(ctx context.Context, in *ExecuteBatchRequest, opts ...grpc.CallOption) (*spannerpb.ExecuteBatchDmlResponse, error)
	Metadata(ctx context.Context, in *Rows, opts ...grpc.CallOption) (*spannerpb.ResultSetMetadata, error)
	Next(ctx context.Context, in *NextRequest, opts ...grpc.CallOption) (*structpb.ListValue, error)
	ResultSetStats(ctx context.Context, in *Rows, opts ...grpc.CallOption) (*spannerpb.ResultSetStats, error)
	NextResultSet(ctx context.Context, in *Rows, opts ...grpc.CallOption) (*spannerpb.ResultSetMetadata, error)
	CloseRows(ctx context.Context, in *Rows, opts ...grpc.CallOption) (*emptypb.Empty, error)
	BeginTransaction(ctx context.Context, in *BeginTransactionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Commit(ctx context.Context, in *Connection, opts ...grpc.CallOption) (*spannerpb.CommitResponse, error)
	Rollback(ctx context.Context, in *Connection, opts ...grpc.CallOption) (*emptypb.Empty, error)
	WriteMutations(ctx context.Context, in *WriteMutationsRequest, opts ...grpc.CallOption) (*spannerpb.CommitResponse, error)
	ConnectionStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ConnectionStreamRequest, ConnectionStreamResponse], error)
}

type spannerLibClient struct {
	cc grpc.ClientConnInterface
}

func NewSpannerLibClient(cc grpc.ClientConnInterface) SpannerLibClient {
	return &spannerLibClient{cc}
}

func (c *spannerLibClient) Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InfoResponse)
	err := c.cc.Invoke(ctx, SpannerLib_Info_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) CreatePool(ctx context.Context, in *CreatePoolRequest, opts ...grpc.CallOption) (*Pool, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Pool)
	err := c.cc.Invoke(ctx, SpannerLib_CreatePool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) ClosePool(ctx context.Context, in *Pool, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SpannerLib_ClosePool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) CreateConnection(ctx context.Context, in *CreateConnectionRequest, opts ...grpc.CallOption) (*Connection, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Connection)
	err := c.cc.Invoke(ctx, SpannerLib_CreateConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) CloseConnection(ctx context.Context, in *Connection, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SpannerLib_CloseConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*Rows, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Rows)
	err := c.cc.Invoke(ctx, SpannerLib_Execute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) ExecuteStreaming(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RowData], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SpannerLib_ServiceDesc.Streams[0], SpannerLib_ExecuteStreaming_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecuteRequest, RowData]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SpannerLib_ExecuteStreamingClient = grpc.ServerStreamingClient[RowData]

func (c *spannerLibClient) ExecuteBatch(ctx context.Context, in *ExecuteBatchRequest, opts ...grpc.CallOption) (*spannerpb.ExecuteBatchDmlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(spannerpb.ExecuteBatchDmlResponse)
	err := c.cc.Invoke(ctx, SpannerLib_ExecuteBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) Metadata(ctx context.Context, in *Rows, opts ...grpc.CallOption) (*spannerpb.ResultSetMetadata, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(spannerpb.ResultSetMetadata)
	err := c.cc.Invoke(ctx, SpannerLib_Metadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) Next(ctx context.Context, in *NextRequest, opts ...grpc.CallOption) (*structpb.ListValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(structpb.ListValue)
	err := c.cc.Invoke(ctx, SpannerLib_Next_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) ResultSetStats(ctx context.Context, in *Rows, opts ...grpc.CallOption) (*spannerpb.ResultSetStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(spannerpb.ResultSetStats)
	err := c.cc.Invoke(ctx, SpannerLib_ResultSetStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) NextResultSet(ctx context.Context, in *Rows, opts ...grpc.CallOption) (*spannerpb.ResultSetMetadata, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(spannerpb.ResultSetMetadata)
	err := c.cc.Invoke(ctx, SpannerLib_NextResultSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) CloseRows(ctx context.Context, in *Rows, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SpannerLib_CloseRows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) BeginTransaction(ctx context.Context, in *BeginTransactionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SpannerLib_BeginTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) Commit(ctx context.Context, in *Connection, opts ...grpc.CallOption) (*spannerpb.CommitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(spannerpb.CommitResponse)
	err := c.cc.Invoke(ctx, SpannerLib_Commit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) Rollback(ctx context.Context, in *Connection, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SpannerLib_Rollback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) WriteMutations(ctx context.Context, in *WriteMutationsRequest, opts ...grpc.CallOption) (*spannerpb.CommitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(spannerpb.CommitResponse)
	err := c.cc.Invoke(ctx, SpannerLib_WriteMutations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spannerLibClient) ConnectionStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ConnectionStreamRequest, ConnectionStreamResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SpannerLib_ServiceDesc.Streams[1], SpannerLib_ConnectionStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ConnectionStreamRequest, ConnectionStreamResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SpannerLib_ConnectionStreamClient = grpc.BidiStreamingClient[ConnectionStreamRequest, ConnectionStreamResponse]

// SpannerLibServer is the server API for SpannerLib service.
// All implementations must embed UnimplementedSpannerLibServer
// for forward compatibility.
type SpannerLibServer interface {
	Info(context.Context, *InfoRequest) (*InfoResponse, error)
	CreatePool(context.Context, *CreatePoolRequest) (*Pool, error)
	ClosePool(context.Context, *Pool) (*emptypb.Empty, error)
	CreateConnection(context.Context, *CreateConnectionRequest) (*Connection, error)
	CloseConnection(context.Context, *Connection) (*emptypb.Empty, error)
	Execute(context.Context, *ExecuteRequest) (*Rows, error)
	ExecuteStreaming(*ExecuteRequest, grpc.ServerStreamingServer[RowData]) error
	ExecuteBatch(context.Context, *ExecuteBatchRequest) (*spannerpb.ExecuteBatchDmlResponse, error)
	Metadata(context.Context, *Rows) (*spannerpb.ResultSetMetadata, error)
	Next(context.Context, *NextRequest) (*structpb.ListValue, error)
	ResultSetStats(context.Context, *Rows) (*spannerpb.ResultSetStats, error)
	NextResultSet(context.Context, *Rows) (*spannerpb.ResultSetMetadata, error)
	CloseRows(context.Context, *Rows) (*emptypb.Empty, error)
	BeginTransaction(context.Context, *BeginTransactionRequest) (*emptypb.Empty, error)
	Commit(context.Context, *Connection) (*spannerpb.CommitResponse, error)
	Rollback(context.Context, *Connection) (*emptypb.Empty, error)
	WriteMutations(context.Context, *WriteMutationsRequest) (*spannerpb.CommitResponse, error)
	ConnectionStream(grpc.BidiStreamingServer[ConnectionStreamRequest, ConnectionStreamResponse]) error
	mustEmbedUnimplementedSpannerLibServer()
}

// UnimplementedSpannerLibServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSpannerLibServer struct{}

func (UnimplementedSpannerLibServer) Info(context.Context, *InfoRequest) (*InfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedSpannerLibServer) CreatePool(context.Context, *CreatePoolRequest) (*Pool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePool not implemented")
}
func (UnimplementedSpannerLibServer) ClosePool(context.Context, *Pool) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClosePool not implemented")
}
func (UnimplementedSpannerLibServer) CreateConnection(context.Context, *CreateConnectionRequest) (*Connection, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateConnection not implemented")
}
func (UnimplementedSpannerLibServer) CloseConnection(context.Context, *Connection) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseConnection not implemented")
}
func (UnimplementedSpannerLibServer) Execute(context.Context, *ExecuteRequest) (*Rows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedSpannerLibServer) ExecuteStreaming(*ExecuteRequest, grpc.ServerStreamingServer[RowData]) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteStreaming not implemented")
}
func (UnimplementedSpannerLibServer) ExecuteBatch(context.Context, *ExecuteBatchRequest) (*spannerpb.ExecuteBatchDmlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteBatch not implemented")
}
func (UnimplementedSpannerLibServer) Metadata(context.Context, *Rows) (*spannerpb.ResultSetMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Metadata not implemented")
}
func (UnimplementedSpannerLibServer) Next(context.Context, *NextRequest) (*structpb.ListValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Next not implemented")
}
func (UnimplementedSpannerLibServer) ResultSetStats(context.Context, *Rows) (*spannerpb.ResultSetStats, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResultSetStats not implemented")
}
func (UnimplementedSpannerLibServer) NextResultSet(context.Context, *Rows) (*spannerpb.ResultSetMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NextResultSet not implemented")
}
func (UnimplementedSpannerLibServer) CloseRows(context.Context, *Rows) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseRows not implemented")
}
func (UnimplementedSpannerLibServer) BeginTransaction(context.Context, *BeginTransactionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BeginTransaction not implemented")
}
func (UnimplementedSpannerLibServer) Commit(context.Context, *Connection) (*spannerpb.CommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Commit not implemented")
}
func (UnimplementedSpannerLibServer) Rollback(context.Context, *Connection) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rollback not implemented")
}
func (UnimplementedSpannerLibServer) WriteMutations(context.Context, *WriteMutationsRequest) (*spannerpb.CommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteMutations not implemented")
}
func (UnimplementedSpannerLibServer) ConnectionStream(grpc.BidiStreamingServer[ConnectionStreamRequest, ConnectionStreamResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ConnectionStream not implemented")
}
func (UnimplementedSpannerLibServer) mustEmbedUnimplementedSpannerLibServer() {}
func (UnimplementedSpannerLibServer) testEmbeddedByValue()                    {}

// UnsafeSpannerLibServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SpannerLibServer will
// result in compilation errors.
type UnsafeSpannerLibServer interface {
	mustEmbedUnimplementedSpannerLibServer()
}

func RegisterSpannerLibServer(s grpc.ServiceRegistrar, srv SpannerLibServer) {
	// If the following call pancis, it indicates UnimplementedSpannerLibServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SpannerLib_ServiceDesc, srv)
}

func _SpannerLib_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_Info_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).Info(ctx, req.(*InfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_CreatePool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).CreatePool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_CreatePool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).CreatePool(ctx, req.(*CreatePoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_ClosePool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).ClosePool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_ClosePool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).ClosePool(ctx, req.(*Pool))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_CreateConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).CreateConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_CreateConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).CreateConnection(ctx, req.(*CreateConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_CloseConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Connection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).CloseConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_CloseConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).CloseConnection(ctx, req.(*Connection))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_Execute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).Execute(ctx, req.(*ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_ExecuteStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecuteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SpannerLibServer).ExecuteStreaming(m, &grpc.GenericServerStream[ExecuteRequest, RowData]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SpannerLib_ExecuteStreamingServer = grpc.ServerStreamingServer[RowData]

func _SpannerLib_ExecuteBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).ExecuteBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_ExecuteBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).ExecuteBatch(ctx, req.(*ExecuteBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_Metadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Rows)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).Metadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_Metadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).Metadata(ctx, req.(*Rows))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_Next_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).Next(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_Next_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).Next(ctx, req.(*NextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_ResultSetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Rows)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).ResultSetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_ResultSetStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).ResultSetStats(ctx, req.(*Rows))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_NextResultSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Rows)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).NextResultSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_NextResultSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).NextResultSet(ctx, req.(*Rows))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_CloseRows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Rows)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).CloseRows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_CloseRows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).CloseRows(ctx, req.(*Rows))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_BeginTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeginTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).BeginTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_BeginTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).BeginTransaction(ctx, req.(*BeginTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Connection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_Commit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).Commit(ctx, req.(*Connection))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_Rollback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Connection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).Rollback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_Rollback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).Rollback(ctx, req.(*Connection))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_WriteMutations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteMutationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpannerLibServer).WriteMutations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SpannerLib_WriteMutations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpannerLibServer).WriteMutations(ctx, req.(*WriteMutationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpannerLib_ConnectionStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SpannerLibServer).ConnectionStream(&grpc.GenericServerStream[ConnectionStreamRequest, ConnectionStreamResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SpannerLib_ConnectionStreamServer = grpc.BidiStreamingServer[ConnectionStreamRequest, ConnectionStreamResponse]

// SpannerLib_ServiceDesc is the grpc.ServiceDesc for SpannerLib service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SpannerLib_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.spannerlib.v1.SpannerLib",
	HandlerType: (*SpannerLibServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Info",
			Handler:    _SpannerLib_Info_Handler,
		},
		{
			MethodName: "CreatePool",
			Handler:    _SpannerLib_CreatePool_Handler,
		},
		{
			MethodName: "ClosePool",
			Handler:    _SpannerLib_ClosePool_Handler,
		},
		{
			MethodName: "CreateConnection",
			Handler:    _SpannerLib_CreateConnection_Handler,
		},
		{
			MethodName: "CloseConnection",
			Handler:    _SpannerLib_CloseConnection_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _SpannerLib_Execute_Handler,
		},
		{
			MethodName: "ExecuteBatch",
			Handler:    _SpannerLib_ExecuteBatch_Handler,
		},
		{
			MethodName: "Metadata",
			Handler:    _SpannerLib_Metadata_Handler,
		},
		{
			MethodName: "Next",
			Handler:    _SpannerLib_Next_Handler,
		},
		{
			MethodName: "ResultSetStats",
			Handler:    _SpannerLib_ResultSetStats_Handler,
		},
		{
			MethodName: "NextResultSet",
			Handler:    _SpannerLib_NextResultSet_Handler,
		},
		{
			MethodName: "CloseRows",
			Handler:    _SpannerLib_CloseRows_Handler,
		},
		{
			MethodName: "BeginTransaction",
			Handler:    _SpannerLib_BeginTransaction_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _SpannerLib_Commit_Handler,
		},
		{
			MethodName: "Rollback",
			Handler:    _SpannerLib_Rollback_Handler,
		},
		{
			MethodName: "WriteMutations",
			Handler:    _SpannerLib_WriteMutations_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ExecuteStreaming",
			Handler:       _SpannerLib_ExecuteStreaming_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ConnectionStream",
			Handler:       _SpannerLib_ConnectionStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "google/spannerlib/v1/spannerlib.proto",
}
